# Decorator 详解

装饰器，这类东西我最早接触是在Java中的`Annotation`这个东西，使用起来很方便、优雅。可以减少很多冗余的代码。

## 介绍
装饰器（Decorator）主要是用来增强JavaScript类（class）的功能，请多的面向对象语言都在类似的东西。
比如:Java中的[`Annotation`](https://www.cnblogs.com/ziph/p/13056092.html)、C#中的[`Attribute`](https://www.cnblogs.com/zuiyirenjian/p/3980608.html)等。

> 由于该特性是目前处于`Stage`阶段，想使用该功能，浏览器都没有支持。在开发中使用一般有两种方法：

> 1. 通过Babel，进行编译通过，插件[@babel/plugin-proposal-decorators](https://babeljs.io/docs/babel-plugin-proposal-decorators)
  2. 使用`TypeScript`进行编译，（TypeScript在早期的时候本身已经支持`Decorator`，后来由于ECMAScript标准确认时，与早期的语法很有很大的差别。所以在使用时配置是不相同的，见下文）

> 本文主要在`TypeScript`中使用。演示代码主要在为ts代码.

## 语法

> 注：以[`TypeScript5.0`](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)版本为界限，在5.0之前TypeScript实现的是[`Stage 2`](https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/)的装饰器标准，
而在5.0及之后是按照[`Satge 3`](https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators)进行实现的。这里以`Typescript5.0`的版本进行测试

### 配置
在5.0之后的版本，`TypeScript`是默认支持。使用**传统的语法**则需要以下配置:

```json
{
  "compilerOptions": {
    "target": "ES5",
    "experimentalDecorators": true
  }
}
```

### 类型定义
先看下在5.0版本中，对于装饰器的定义:

```TypeScript
declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;
declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) => void;
declare type MethodDecorator = <T>(target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | void;
declare type ParameterDecorator = (target: Object, propertyKey: string | symbol | undefined, parameterIndex: number) => void;
```
在该版本中，可以分为4种：类装饰器、属性装饰器，方法装饰器、参数装饰器。让我们快速认识一下他们

```ts
// 类装饰器
@ClassDecorator
class Person {

  // 属性装饰器
  @PropertyDecorator
  name: string;

  // 参数装饰器
  eat(@ParameterDecorator('food') food: string) {
    console.log(food);
  }

  // 方法装饰器
  @MethodDecorator
  sayHello() {
    console.log('hello');
  }
}
```




### 类装饰器

```TypeScript
declare type ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction | void;
``

- 参数
  1. `target`: 类的构造器

- 返回：空或者一个新的构造器函数
  如果类装饰器返回了一个值，它将会被用来替代原来的类构造器的声明。

``` TypeScript
function ClassDecoratorService(params?: any): ClassDecorator {
  return (target: Function) => {
    console.log('ClassDecoratorService call on :', target);
    console.log('ClassDecoratorService params: ', params);
  };
}

@ClassDecoratorService({ log: 'test' })
class ClassDecoratorExample {}
```

输出结果：

```shell
ClassDecoratorService call on : [Function: ClassDecoratorExample]
ClassDecoratorService params:  { log: 'test' }
```

## 参考

1. https://es6.ruanyifeng.com/#docs/decorator
2. https://caniuse.com/decorators
3. https://www.typescriptlang.org/docs/handbook/decorators.html
4. https://github.com/tc39/proposal-decorators
5. https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators
6. https://mirone.me/zh-hans/a-complete-guide-to-typescript-decorator/
